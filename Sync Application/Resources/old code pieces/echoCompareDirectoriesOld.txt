void echoCompareDirectoriesOLD(std::vector<std::wstring> &firstGivenVectorDB, std::vector<std::wstring> &secondGivenVectorDB, std::vector<std::wstring> &hashActions, std::vector<std::wstring> &fileOpAction, std::wstring firstGivenPath, std::wstring secondGivenPath)
{
    //Storing ending iterator (vector size). Every "for loop" call will ask the vector for it's size otherwise. - https://articles.emptycrate.com/2008/10/26/c_loop_optimization.html
    size_t firstDBSize = firstGivenVectorDB.size();
    size_t secondDBSize = secondGivenVectorDB.size();


    //Used for comparing the strings.
    //Removing these would likely create more total calls.
    std::wstring workingPath;
    std::wstring workingPathTwo;
    std::wstring workingSize;
    std::wstring workingSizeTwo;
    std::wstring workingDateMod;
    std::wstring workingDateModTwo;
    std::wstring workingDateCreated;
    std::wstring workingDateCreatedTwo;
    std::wstring workingHash;
    std::wstring workingHashTwo;

    //Keeps track of whether a first directory file was found or not.
    bool notFound;



    //*** Debug output.
    //std::wstring echoDebugHandle = L"echoCompareDebug.txt";
    //int comparisonOutput;

    ////Creating files themselves.
    //std::ofstream echoDebug(echoDebugHandle, std::ios::out | std::ios::binary);


    std::wstring iter1;
    std::wstring iter2;

    //Iterating through first directory vector.
    for (size_t iterator = 0; iterator < firstDBSize; ++iterator) //Needs to start at "1" if headers are added before this.
    {
        //Placing parts of the string into their variables.
        workingPath = firstGivenVectorDB[iterator].substr(firstGivenPath.length() + 1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1) - firstGivenPath.length() - 1); //Removing first provided paths to make them both comparable.
        //workingSize = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1)+1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1) - 1); //Second column
        //workingDateMod = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2)+1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 3) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2) - 1); //Third column
        //workingDateCreated = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 3)+1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 4) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 3) - 1); //Fourth column
        //workingHash = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 4), std::wstring::npos); //Fifth column - Special work, since the DB doesn't end with a delimiter. Reading until end of string.
        //workingMatch = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 5)+1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 6) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 5) - 1); //Fifth column - Special work, since the DB doesn't end with a delimiter. Reading until end of string.
        //workingLineFound = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 6), std::wstring::npos); //Fifth column - Special work, since the DB doesn't end with a delimiter. Reading until end of string.
        
        //Init notFound to be false.
        notFound = true;



        //Iterating through second directory vector.
        for (size_t iteratorTwo = 0; iteratorTwo < secondDBSize; ++iteratorTwo) //Needs to start at "1" if headers are added before this.
        {
            //Placing parts of the string into their variables.
            //workingDateCreatedTwo = secondGivenVectorDB[iteratorTwo].substr(nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 3) + 1, nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 4) - nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 3) - 1); //Fourth column
            //workingHashTwo = secondGivenVectorDB[iteratorTwo].substr(nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 4), std::wstring::npos); //Fifth column - Special work, since the DB doesn't end with a delimiter. Reading until end of string.

            if (secondGivenVectorDB[iteratorTwo].substr(nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 5) + 1, 7) != L"MATCHED") //Ignore if previously matched.
            {
                workingPathTwo = secondGivenVectorDB[iteratorTwo].substr(secondGivenPath.length() + 1, nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 1) - secondGivenPath.length() - 1); //Removing first provided paths to make them both comparable.
                //comparisonOutput = firstGivenVectorDB[iterator].compare(secondGivenVectorDB[iteratorTwo]);
                //std::cout << comparisonOutput << std::endl;
                ////system("PAUSE");
                //if (comparisonOutput >= 0) //Check if the first string is alphabetically larger than the second. If it is, then we have passed the location it could be, and can break. This assumes that both vectors are SORTED prior. - Benefits would be seen when source items are not in the destination.
                //{
                    if (workingPath == workingPathTwo) //Check if the paths match.
                    {
                        notFound = false; //Keeping track that the file has been found.
                        iter1 = std::to_wstring(iterator);
                        iter2 = std::to_wstring(iteratorTwo);
                        firstGivenVectorDB[iterator].insert(firstGivenVectorDB[iterator].length() - 1, L"MATCHED" + delimitingCharacter + iter2); //Add match marker and line.
                        secondGivenVectorDB[iteratorTwo].insert(secondGivenVectorDB[iteratorTwo].length() - 1, L"MATCHED" + delimitingCharacter + iter1); //Add match marker and line.


                        //secondGivenVectorDB[iteratorTwo].erase(secondGivenVectorDB[iteratorTwo].length() - 1, 1); //Removing newline to allow the matched marker, and first directory line to be added.
                        //secondGivenVectorDB[iteratorTwo].append(L"MATCHED" + delimitingCharacter + iter1 + newLine); //Second Directory: Marking that the entry has had a match found and providing first directory line of match.
                        //firstGivenVectorDB[iterator].erase(firstGivenVectorDB[iterator].length()-1, 1); //Removing newline to allow the matched marker, and second directory line to be added.
                        //firstGivenVectorDB[iterator].append(L"MATCHED" + delimitingCharacter + iter2 + newLine); //First Directory: Marking that the entry has had a match found and providing second directory line of match.

                        //processingThreads[0] = std::thread(insertMatchInfoIntoVector, std::ref(firstGivenVectorDB), iterator, iter2);
                        //processingThreads[1] = std::thread(insertMatchInfoIntoVector, std::ref(secondGivenVectorDB), iteratorTwo, iter1);


                        
                        workingDateMod = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2) + 1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 3) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2) - 1); //Third column
                        workingDateModTwo = secondGivenVectorDB[iteratorTwo].substr(nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 2) + 1, nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 3) - nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 2) - 1); //Third column
                        if (workingDateMod == workingDateModTwo) //If the file paths match, check the last modified times.
                        {
                            workingSize = firstGivenVectorDB[iterator].substr(nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1) + 1, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 2) - nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1) - 1); //Second column
                            workingSizeTwo = secondGivenVectorDB[iteratorTwo].substr(nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 1) + 1, nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 2) - nthOccurrence(secondGivenVectorDB[iteratorTwo], delimitingCharacter, 1) - 1); //Second column
                            if (workingSize == workingSizeTwo) //If last modified times match, check that the file sizes match.
                            {
                                hashActions.push_back(workingPath + delimitingCharacter + iter1 + delimitingCharacter + iter2 + newLine); //If everything matches, these files need hashed and compared.
                                break; //Exiting directory two iterating against directory one file. Proceed to next directory one file.
                            }
                            else
                            {
                                fileOpAction.push_back(L"COPY - Different file sizes" + delimitingCharacter + firstGivenPath + L"\\" + workingPath + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
                                //fileOpAction.push_back(L"COPY - Different file sizes" + delimitingCharacter + firstGivenVectorDB[iterator].substr(0, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1)) + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
                                break; //Exiting directory two iterating against directory one file. Proceed to next directory one file.
                            }
                        }
                        else //A matching file has been found, with differing last modified times.
                        {
                            fileOpAction.push_back(L"COPY - Different last modified time" + delimitingCharacter + firstGivenPath + L"\\" + workingPath + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
                            //fileOpAction.push_back(L"COPY - Different last modified time" + delimitingCharacter + firstGivenVectorDB[iterator].substr(0, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1)) + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
                            break; //Exiting directory two iterating against directory one file. Proceed to next directory one file.
                        }
                    }
                //}
                //else
                //{
                //    //writeUnicodeToFile(echoDebug, workingPath + delimitingCharacter + workingPathTwo + delimitingCharacter + std::to_wstring(comparisonOutput) + newLine);
                //    notFound = true;
                //    break; //Exit the loop. The second path is larger than the first alphabetically and can't be in the remaining options.
            }
            else //Path not found during this cycle. Could be found in future ones? NO! It should break out of the loop, if found.
            {
                notFound = true; //Directory one file not found within directory two. It should break out of the loop, if found.
            }
        } //End of second directory iterating loop






        if (notFound == true) //If the file was not found in the second directory, create a file operation to copy (create) it there.
            fileOpAction.push_back(L"COPY - No destination file found" + delimitingCharacter + firstGivenPath + L"\\" + workingPath + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
        //fileOpAction.push_back(L"COPY - No destination file found" + delimitingCharacter + firstGivenVectorDB[iterator].substr(0, nthOccurrence(firstGivenVectorDB[iterator], delimitingCharacter, 1)) + delimitingCharacter + secondGivenPath + L"\\" + workingPath + newLine); //Copy first directory file to second directory.
        //Go to the next first directory file.
    }


    //std::cout << "Checking matched list against second directory..." << std::endl; //***
    std::cout << "Checking for second directory items that did not get matched..." << std::endl; //***

    //Iterating through secondary directory list and checking against matched list.
    for (size_t iterator = 0; iterator < secondDBSize; ++iterator) //Needs to start at "1" if headers are added before this.
    {
        if (secondGivenVectorDB[iterator].substr(nthOccurrence(secondGivenVectorDB[iterator], delimitingCharacter, 5) + 1, 7) != L"MATCHED")
            fileOpAction.push_back(L"DELETE - No source file found" + delimitingCharacter + secondGivenVectorDB[iterator].substr(0, nthOccurrence(secondGivenVectorDB[iterator], delimitingCharacter, 1)) + newLine); //Delete second directory file. No source file found that matches.
    }

    //***** 
    //std::cout << "Shrinking vectors" << std::endl; //***
    ////Resizing vectors to ensure that memory is not being wasted. They shouldn't be getting larger/smaller after this point.
    //firstGivenVectorDB.resize(firstGivenVectorDB.size());
    //secondGivenVectorDB.resize(secondGivenVectorDB.size());
    //hashActions.resize(hashActions.size());
    //fileOpAction.resize(fileOpAction.size());

    //echoDebug.close(); //***



    //TODO *****
    //The below solutions needs changed. It theoretically doubles the time/processing required if everything is identical between directories. It gets more efficient as less things were matched above.
    //Ideas for solutions:
    //1. This could be solved by adding another column and marking the second database when a match is found. This list needs gone through once, and everything without that mark needs to be deleted.
        //1A. Maybe instead of a column, the entire second directory can be output to the file (debugging/exporting) before this step, and Matching entries can be deleted??? - NO. Matching entries are needed for hashing later.
        //1AA. Matched files can be immediately ignored when doing the earlier comparisons between dir 1 and 2. This should help speed things up?
    //2. A forum suggests a "hash map". - https://softwareengineering.stackexchange.com/questions/280361/list-comparing-techniques-for-faster-performance
        //An unordered map seems VERY similar to the "folder deepeness" idea mentioned below. 
    //That's the best I have right now...


    //Additionally, this entire process (echoCompareDirectories) could potentially be multi-threaded by doing chunks of 10000 (or 1000) files (The exact number may needed testing, but a large number)
        //Potentially every 10000 files gets a thread, each with it's own COPY (not passed by reference) of the vector data.
        //Maybe each thread stores a vector of data containing matches that is applied to the master/original at the end.
        //How would this matches vector avoid the problem? Eventually every entry of the "matching lists" will be checked against the master list.
        //A good suggestion I found mentioned creating a "queueing system" and dedicating a thread to that. That seems like it would eliminate most issues... - https://articles.emptycrate.com/2009/06/10/optimizing_massively_multithreaded_c_applications__watch_for_hidden_mutexes.html
            //2 threads could be handling the comparisons and reporting matches to the queue, where 2 more are checking those and determining what is missing.
    //Potentially the deepness of a file (how many folders deep) is stored in the database, and this can be referenced first to sift through the majority of files that differ.
    //Another idea: Create a list of folders that should be searched for and compared for. If the folder is missing, we automatically know that every item in the folder needs copied over (or deleted, depending on which side is missing the folder)


    //***** CURRENTLY IMPLEMENTED. WILL BE TESTED TO SEE IF PERFORMANCE IS IMPROVED/HARMED.
    //Count files in the directory prior to the scan, and pre-allocate the expected vector space needed.





    ////Iterating through secondary directory list and checking against matched list.
    //for (int iterator = 0; iterator < secondDBSize; ++iterator) //Needs to start at "1" if headers are added before this.
    //{
    //    //Finding file path of the string into their variables.
    //    workingPathTwo = secondGivenVectorDB[iterator].substr(secondGivenPath.length() + 1, nthOccurrence(secondGivenVectorDB[iterator], delimitingCharacter, 1) - secondGivenPath.length() - 1); //Removing first provided paths to make them both comparable.

    //    //Iterating through second directory vector to check against the matched vector list.
    //    for (int iteratorTwo = 0; iteratorTwo < matchingFiles.size(); ++iteratorTwo)
    //    {
    //        //wprintf(L"%s \n", workingPathTwo.c_str());
    //        //wprintf(L"%s \n", matchingFiles[iteratorTwo].c_str());

    //        //system("PAUSE");
    //        //Checking matching file list to second directory list.
    //        if (workingPathTwo + newLine == matchingFiles[iteratorTwo])
    //        {
    //            notFound = false; //Keeping track that the file has been found.
    //            break; //Exit loop. A matched 
    //        }
    //        else //Not matched.
    //        {
    //            notFound = true;
    //        }
    //        

    //    }
    //    if (notFound == true) //If the file was never found earlier and had a matching comparison AND the matching list, it ends up here. DELETED.
    //    {
    //        fileOpAction.push_back(L"DELETE - No source file found" + delimitingCharacter + secondGivenVectorDB[iterator].substr(0, nthOccurrence(secondGivenVectorDB[iterator], delimitingCharacter, 1)) + newLine); //Delete second directory file. No source file found that matches.
    //    }
    //}
}